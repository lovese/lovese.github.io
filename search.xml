<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ChromeBook安装Google Play]]></title>
    <url>%2F2017%2F08%2F25%2FChromeBook%E5%AE%89%E8%A3%85Google%20Play%2F</url>
    <content type="text"><![CDATA[步骤如下：1、首先查看你的Chromebook是否支持Google Play（64位x86CPU支持的更好，ARM64位CPU好像也可以），Google下或者问度娘 2、进开发者模式（稳定版、测试版、开发版都行），具体操作如下： 123按住 Esc+F3 (Refresh)，然后按 Power，接着就会进入恢复模式。接着，按 Ctrl+D，它会提示您确认进入开发者模式，您的数据会被清除。再次按 Ctrl+D，或者等待 30 秒左右，系统会引导您进入开发者模式。 3、进入设置，查看帮助，关于Chrome系统，确认ChromeOS版本 4、进系统后，按Ctrl+Alt+t，打开命令行 a.如果是ChromeOS 57及以前的版本，输入以下命令: 123456shellsudo sucp /etc/chrome_dev.conf /usr/local/mount --bind /usr/local/chrome_dev.conf /etc/chrome_dev.confecho &quot;--enable-arc&quot; &gt;&gt; /etc/chrome_dev.conf退出账户重新登陆即可 b.如果是ChromeOS 58及以后的版本，输入以下命令: 12345678shellsudo sucp /etc/chrome_dev.conf /usr/local/mount --bind /usr/local/chrome_dev.conf /etc/chrome_dev.confecho &quot;--arc-availability=officially-supported &quot; &gt;&gt; /etc/chrome_dev.confrestart uiexit完了重新登陆即可 5、每次开机都得输入以上命令，可以写脚本开机自动执行实现（本人未实践） 以上都是通过Google搜索整理来的（本人实践可用），最后不尽完善之处尽情谅解]]></content>
      <categories>
        <category>chromebook</category>
      </categories>
      <tags>
        <tag>google play</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[probe安装配置]]></title>
    <url>%2F2016%2F11%2F05%2Fprobe%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[简介psi-probe是为了取代和扩展Tomcat manager，使其更易于管理和监控的Apache Tomcat实例。不像许多其他的服务器监控工具，psi-probe不需要对现有应用进行任何更改。它通过Web界面提供其所有功能，只需将其部署到您的服务器上即可。 实现功能请求：即时在每个应用程序的基础上实时监控流量会话：浏览/搜索属性，查看最后一个IP，到期，估计大小JSP：浏览，查看源代码，编译数据源：查看池使用情况，执行查询日志：查看内容，下载，在运行时更改级别线程：查看执行堆栈，kill线程连接器：状态，使用情况图表证书：系统信任存储和连接器密钥库/信任库集群：状态，使用情况图表JVM：内存使用情况图，建议GCJava服务包装器：重新启动JVM系统：CPU使用率，内存使用率，交换文件使用率 下载安装配置123456789# wget https://github.com/psi-probe/psi-probe/releases/download/2.4.0.SP1/probe.war# cp -f probe.war $TOMCAT_HOME/webapps/# vim $TOMCAT_HOME/conf/tomcat-users.xml&lt;role rolename=&quot;probe&quot; /&gt; &lt;role rolename=&quot;tomcat&quot; /&gt; &lt;role rolename=&quot;administrator&quot; /&gt; &lt;role rolename=&quot;manager-gui&quot; /&gt;&lt;user username=&quot;admin&quot; password=&quot;密码&quot; roles=&quot;manager-gui&quot; /&gt; 这将创建一个名为用户admin与角色manager-gui，改完后重启tomcat访问http://127.0.0.1:8080/probe 是否安装成功 Tips:在Tomcat的5.x和6.0.29及以下，你应该使用manager代替manager-gui。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记]]></title>
    <url>%2F2016%2F11%2F05%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第三章 使用MySQL12345# msql -u username -p -h myserver -P port #连接数据库&gt; USE database_name #打开数据库&gt; SHOW DATABASES #显示可用数据库列表&gt; SHOW TABLES #返回数据库中数据表的列表&gt; SHOW COLUMNS FROM table_name #显示表中字段信息 第四章 检索数据1234567&gt; SELECT field_name FROM table_name; #从表中检索选定的列&gt; SELECT field_name1,field_name2 FROM table_name; #从表中检索多列&gt; SELECT * FROM table_name; #检索表中所有列&gt; SELECT DISTINCT field_name FROM table_name; #消除重复行&gt; SELECT field_name FROM table_name LIMIT lines; #返回检索结果的前几行&gt; SELECT field_name FROM table_name LIMIT strat_pos,lines; #从第strat_pos行开始的行&gt; SELECT products.prod_name FROM crashcourse.products; #使用完全限定的表名 第五章 排序检索数据12345678&gt; SELECT prod_name FROM products ORDER BY prod_id;#对prod_name列，以prod_id的字母顺序排列数据&gt; SELECT prod_id,prod_price,prod_name FROM products ORDER BY prod_prices,prod_name;#通过多列数据对结果排序（首先依据prod_prices排序，prod_prices相同时，再依据prod_name排序）&gt; SELECT prod_id,prod_price,prod_name FROM products ORDER BY prod_prices DESC,prod_name;#以prod_prices降序，prod_name升序排列数据，mysql默认升序排列，如果想同时以prod_name降序排列，需要在prod_name后也加上DESC,因为DESC关键字只应用到直接位于其前面的列名上。&gt; SELECT prod_price FROM products ORDER BY prod_prices DESC LIMIT 1；#找出一个列中最高的值 Tips： mysql默认升序排列数据 DESC关键字只应用到直接位于其前面的列名上，根据多列降序，则每列都要加上DESC关键字 ORDER BY子句必须是SELECT语句中的最后一条子句（一个子句通常由一个关键字和所提供的数据组成，FROM products是子句，ORDER BY prod_prices也是子句，但DESC和LIMIT 1不是子句）。 第六章 过滤数据12345678&gt; SELECT prod_name,prod_price FROM products WHERE prod_name=&apos;fuses&apos;;#返回prod_name的值为Fuses的一行。&gt; SELECT prod_name,prod_price FROM products WHERE prod_price&lt;=10;#列出价格小于或等于10美元的所有产品&gt; SELECT prod_name,prod_price FROM products WHERE prod_price BETWEEN 5 AND 10;#检索价格在5美元和10美元之间的所有产品(包括5和10)&gt; SELECT cust_id FROM customers WHERE cust_email IS NULL;#返回没有email的顾客id Tips： mysql的where子句支持的操作符有=，!=,&lt;,&lt;=,&gt;,&gt;=,BETWEEN 未知具有特殊的含义，数据库不知道它们是否匹配，所以在匹配过滤或不匹配过滤时都不返回它们。 第七章 数据过滤12345678910&gt; SELECT prod_id,prod_price,prod_name FROM products WHERE vend_id=1003 AND prod_price &lt;=10;#检索由供应商1003制造且价格小于等于10美元的所有产品&gt; SELECT prod_name,prod_price FROM products WHERE vend_id=1002 OR vend_id=1003;#检索供应商1002和1003制造的所有产品&gt; SELECT prod_name,prod_price FROM products WHERE (vend_id=1002 OR vend_id=1003) AND prod_price&gt;=10;#检索价格为10美元（含）以上且由1002或1003制造的所有产品SQL在处理OR操作符前，优先处理AND操作符，所以上面的括号不能少，否则将得不到想要的结果&gt; SELECT prod_name,prod_price,vend_id FROM products WHERE vend_id IN(1002,1003) ORDER BY prod_name;#检索供应商1002和1003制造的所有产品&gt; SELECT prod_name,prod_price FROM products WHERE vend_id NOT IN(1002,1003) ORDER BY prod_name;#检索1002和1003之外供应商制造的所有产品 Tips： SQL在处理OR操作符前，优先处理AND操作符，使用()控制优先级 IN操作符完成与OR相同的功能，但IN操作执行更快，而且IN中还可以包含其他SELECT语句，使得能够更动态地建立WHERE子句 WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所跟的任何条件 MySQL仅支持使用NOT对IN、BETWEEN和EXISTS子句取反。 第八章 用通配符进行过滤1234&gt; SELECT prod_id,prod_name FROM products WHERE prod_name LIKE &apos;%anvil%&apos;;#匹配任何包含文本anvil的值&gt; SELECT prod_id,prod_name FROM products WHERE prod_name LIKE &apos;_ ton anvil&apos;;#_只能匹配一个字符 Tips： 为在搜索子句中使用通配符，必须使用LIKE操作符； 通配符%可以匹配0个、1个或多个字符，但不能匹配NULL； 通配符_总是匹配一个字符，不能多也不能少； 不要过度使用通配符，通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长； 把通配符置于搜索模式的开始处，搜索起来是最慢的。 第九章 用正则表达式进行搜索1234567891011121314151617181920&gt; SELECT prod_name FROM products WHERE prod_name LIKE &apos;1000&apos; ORDER BY prod_name;#匹配完整串1000&gt; SELECT prod_name FROM products WHERE prod_name REGEXP &apos;1000&apos; ORDER BY prod_name;#匹配子串1000&gt; SELECT prod_name FROM products WHERE prod_name REGEXP &apos;.000&apos; ORDER BY prod_name;#点.匹配任意一个字符&gt; SELECT prod_name FROM products WHERE prod_name REGEXP &apos;1000|2000&apos; ORDER BY prod_name;#竖线|为正则表达式的OR操作符,它表示匹配其中之一，因此1000和2000都匹配并返回&gt; SELECT prod_name FROM products WHERE prod_name REGEXP &apos;[123] Ton&apos;;#匹配几个字符之一&gt; SELECT prod_name FROM products WHERE prod_name REGEXP &apos;[^123] Ton&apos;;#匹配123以外的几个字符之一&gt; SELECT prod_name FROM products WHERE prod_name REGEXP &apos;[1-5] Ton&apos;;#匹配范围，常见范围：[1-9],[a-z]，[a-zA-Z0-9]&gt; SELECT prod_name FROM products WHERE prod_name REGEXP &apos;\\([0-9] sticks?\\)&apos;;#双斜杠\\为转义字符，sticks?匹配stick和sticks&gt; SELECT prod_name FROM products WHERE prod_name REGEXP &apos;[[:digit:]]&#123;4&#125;&apos;;#匹配连在一起的任意4位数字[:digit:]代表数字集合，&#123;4&#125;要求它前面的字符出现4次&gt; SELECT prod_name FROM products WHERE prod_name REGEXP &apos;^[0-9\\.]&apos;;#找出以数字或小数点开始的所有prod_name Tips： LIKE和REGEXP的不同在于，LIKE匹配整个串而REGEXP匹配子串； MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用BINARY关键字，如WHERE prod_name REGEXP BINARY &#39;JetPack .000&#39;； ^有两种用法。在集合中（用[和]定义），用它来否定该集合，否则，用来指串的开始处。 第十章 创建计算字段12345678910111213141516171819202122&gt; SELECT Concat(RTrim(vend_name),&apos;(&apos;,RTrim(vend_country),&apos;)&apos;) AS vend_title From vendors ORDER BY vend_name;+------------------------+| vend_title |+------------------------+| ACME(USA) || Anvils R Us(USA) || Furball Inc.(USA) || Jet Set(England) || Jouets Et Ours(France) || LT Supplies(USA) |+------------------------+#拼接字段并使用别名&gt; SELECT prod_id,quantity,item_price,quantity*item_price AS expanded_price FROM orderitems Where order_num = 20005;+--------+----------+------------+----------------+| prod_id| quantity | item_price | expanded_price |+--------+----------+------------+----------------+| ANV01 | 10 | 5.99 | 59.90 || ANV02 | 3 | 9.99 | 29.97 || TNT2 | 5 | 10.00 | 50.00 || FB | 1 | 10.00 | 10.00 |+--------+----------+------------+----------------+#执行计算字段 Tips： Concat()函数用于拼接多个字段； RTrim()函数去掉串右边的空格，LTrim()函数去掉串左边的空格，Trim()函数去掉串左右两边的空格； AS(alias)关键字，为字段赋予别名。 第十一章 使用数据处理函数123456789101112131415161718&gt; SELECT vend_name,Upper(vend_name) AS vend_name_upcase FROM vendors ORDER BY vend_name;+----------------+------------------+| vend_name | vend_name_upcase |+----------------+------------------+| ACME | ACME || Anvils R Us | ANVILS R US || Furball Inc. | FURBALL INC. || Jet Set | JET SET || Jouets Et Ours | JOUETS ET OURS || LT Supplies | LT SUPPLIES |+----------------+------------------+#文本处理函数&gt; SELECT cust_id,order_num FROM orders WHERE Date(order_date)=&apos;2005-09-01&apos;;#日期和事件处理函数,检索order_date为2005-09-01的订单记录&gt; SELECT cust_id,order_num FROM orders WHERE Date(order_date) BETWEEN &apos;2005-09-01&apos; AND &apos;2005-09-30&apos;;#日期和事件处理函数,检索2005年9月的所有订单&gt; SELECT cust_id,order_num FROM orders WHERE Year(order_date)=2005 AND Month(order_date)=9;#日期和事件处理函数,检索2005年9月的所有订单 Tips： 三种数据处理函数：文本处理、日期和时间处理、数值处理]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
